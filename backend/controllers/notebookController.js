import Notebook from "../models/Notebook.js";
import Guide from "../models/Guide.js";
import PlantTemplate from "../models/PlantTemplate.js";
import { ok, created, noContent } from "../utils/ApiResponse.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import { AppError } from "../utils/AppError.js";
import {
  sendStageWarningNotification,
  sendStageSkippedNotification,
  sendStageOverdueNotification,
} from "./notificationController.js";

// ==========================================
// HELPER FUNCTIONS (from services)
// ==========================================

/**
 * T√≠nh s·ªë ng√†y t·ª´ startDate ƒë·∫øn endDate (b·∫Øt ƒë·∫ßu t·ª´ 0:00:00)
 */
const getDaysDifference = (startDate, endDate) => {
  const start = new Date(startDate);
  start.setHours(0, 0, 0, 0);

  const end = new Date(endDate);
  end.setHours(0, 0, 0, 0);

  const diffTime = end - start;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  return diffDays;
};

/**
 * T√≠nh stage end date d·ª±a tr√™n planted_date v√† stage.day_end
 */
const getStageEndDate = (plantedDate, stageEndDay) => {
  const endDate = new Date(plantedDate);
  endDate.setDate(endDate.getDate() + stageEndDay - 1);
  endDate.setHours(0, 0, 0, 0);
  return endDate;
};

/**
 * Ki·ªÉm tra xem notification ƒë√£ ƒë∆∞·ª£c g·ª≠i ch∆∞a
 */
const hasNotificationBeenSent = (notificationsSent, type, missedDay) => {
  return notificationsSent?.some((n) => n.type === type && n.day === missedDay);
};

/**
 * L·∫•y template ph√π h·ª£p v·ªõi notebook (d·ª±a tr√™n guide's plant_group)
 */
const getTemplateForNotebook = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("guide_id");

  if (!notebook) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω", 404);
  }

  if (notebook.template_id) {
    const template = await PlantTemplate.findById(notebook.template_id);
    return template;
  }

  if (notebook.guide_id && notebook.guide_id.plant_group) {
    const template = await PlantTemplate.findOne({
      plant_group: notebook.guide_id.plant_group,
      status: "active",
    }).sort({ usage_count: -1 });

    return template;
  }

  return null;
};

/**
 * G√°n template cho notebook
 */
const assignTemplateToNotebook = async (notebookId, templateId) => {
  const notebook = await Notebook.findById(notebookId);
  const template = await PlantTemplate.findById(templateId);

  if (!notebook) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω", 404);
  }

  if (!template) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y template", 404);
  }

  notebook.template_id = templateId;

  notebook.stages_tracking = template.stages.map((stage, index) => ({
    stage_number: stage.stage_number,
    stage_name: stage.name,
    started_at: index === 0 ? notebook.planted_date : null,
    is_current: index === 0,
  }));

  notebook.current_stage = 1;

  await notebook.updateProgress(template.stages);

  await notebook.save();

  template.usage_count += 1;
  await template.save();

  await generateDailyChecklist(notebookId);

  return notebook;
};

/**
 * T·∫°o daily checklist t·ª´ template's autogenerated_tasks
 */
const generateDailyChecklist = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return null;
  }

  const template = notebook.template_id;
  const currentStage = template.stages.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStage) {
    return null;
  }

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Ki·ªÉm tra xem ƒë√£ ƒë·∫øn ng√†y b·∫Øt ƒë·∫ßu c·ªßa stage ch∆∞a
  const currentDay = notebook.current_day || 1;
  if (currentDay < currentStage.day_start) {
    console.log(
      `‚è≥ Stage ${notebook.current_stage} ch∆∞a b·∫Øt ƒë·∫ßu (current_day: ${currentDay}, day_start: ${currentStage.day_start})`
    );
    // Tr·∫£ v·ªÅ checklist r·ªóng v√¨ ch∆∞a ƒë·∫øn ng√†y b·∫Øt ƒë·∫ßu stage
    notebook.daily_checklist = [];
    notebook.last_checklist_generated = today;
    await notebook.save();
    return [];
  }

  if (
    notebook.last_checklist_generated &&
    new Date(notebook.last_checklist_generated).setHours(0, 0, 0, 0) ===
      today.getTime()
  ) {
    return notebook.daily_checklist;
  }

  const daysInStage =
    Math.floor(notebook.current_day) - currentStage.day_start + 1;

  const newChecklist = (
    currentStage.autogenerated_tasks ||
    currentStage.daily_tasks ||
    []
  )
    .filter((task) => {
      if (task.frequency === "daily") return true;
      if (task.frequency === "every_2_days") return daysInStage % 2 === 0;
      if (task.frequency === "every_3_days") return daysInStage % 3 === 0;
      if (task.frequency === "weekly") return daysInStage % 7 === 0;
      return false;
    })
    .map((task) => ({
      task_name: task.task_name,
      description: task.description,
      priority: task.priority,
      frequency: task.frequency,
      is_completed: false,
    }));

  notebook.daily_checklist = newChecklist;
  notebook.last_checklist_generated = today;
  await notebook.save();

  return newChecklist;
};

/**
 * C·∫≠p nh·∫≠t stage hi·ªán t·∫°i
 */
const updateCurrentStage = async (notebookId, newStageNumber) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω ho·∫∑c template", 404);
  }

  const template = notebook.template_id;

  if (newStageNumber > template.stages.length) {
    throw new AppError("S·ªë stage kh√¥ng h·ª£p l·ªá", 400);
  }

  const oldStageIndex = notebook.stages_tracking.findIndex(
    (s) => s.stage_number === notebook.current_stage
  );
  if (oldStageIndex !== -1) {
    notebook.stages_tracking[oldStageIndex].is_current = false;
    notebook.stages_tracking[oldStageIndex].completed_at = new Date();
  }

  const newStageIndex = notebook.stages_tracking.findIndex(
    (s) => s.stage_number === newStageNumber
  );
  if (newStageIndex !== -1) {
    notebook.stages_tracking[newStageIndex].is_current = true;
    notebook.stages_tracking[newStageIndex].started_at = new Date();
  }

  notebook.current_stage = newStageNumber;

  await notebook.updateProgress(template.stages);

  await notebook.save();

  await generateDailyChecklist(notebookId);

  return notebook;
};

/**
 * Ki·ªÉm tra v√† x·ª≠ l√Ω tr·∫°ng th√°i stage c·ªßa notebook (stage monitoring)
 */
const checkNotebookStageStatus = async (notebook) => {
  try {
    if (!notebook.populated("template_id")) {
      await notebook.populate("template_id");
    }

    if (!notebook.template_id || !notebook.template_id.stages) {
      console.log(`‚ö†Ô∏è Notebook ${notebook._id} kh√¥ng c√≥ template`);
      return;
    }

    const template = notebook.template_id;
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const currentStageTracking = notebook.stages_tracking.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (!currentStageTracking) {
      console.log(
        `‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y stage_tracking cho stage ${notebook.current_stage}`
      );
      return;
    }

    if (
      currentStageTracking.status === "completed" ||
      currentStageTracking.status === "skipped"
    ) {
      console.log(
        `‚úÖ Stage ${notebook.current_stage} ƒë√£ ${currentStageTracking.status}, b·ªè qua`
      );
      return;
    }

    const templateStage = template.stages.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (!templateStage) {
      console.log(
        `‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y template stage cho stage ${notebook.current_stage}`
      );
      return;
    }

    const stageEndDate = getStageEndDate(
      notebook.planted_date,
      templateStage.day_end
    );
    const daysAfterEnd = getDaysDifference(stageEndDate, today);

    console.log(
      `üìÖ Notebook: ${notebook.notebook_name} | Stage: ${
        templateStage.name
      } | End Date: ${
        stageEndDate.toISOString().split("T")[0]
      } | Days After End: ${daysAfterEnd}`
    );

    if (daysAfterEnd <= 0) {
      console.log(`‚úÖ Stage ${notebook.current_stage} c√≤n trong th·ªùi h·∫°n`);
      return;
    }

    const missedDays = daysAfterEnd;
    const safeDelayDays = template.rules?.safe_delay_days || 2;
    const autoSkip = template.rules?.auto_skip ?? true;

    console.log(
      `‚ö†Ô∏è Stage ${notebook.current_stage} ƒë√£ tr·ªÖ ${missedDays} ng√†y (safe_delay: ${safeDelayDays})`
    );

    currentStageTracking.missed_days = missedDays;

    if (missedDays <= safeDelayDays) {
      if (
        !hasNotificationBeenSent(
          currentStageTracking.notifications_sent,
          "warning",
          missedDays
        )
      ) {
        await sendStageWarningNotification({
          userId: notebook.user_id,
          notebookId: notebook._id,
          notebookName: notebook.notebook_name,
          stageNumber: notebook.current_stage,
          stageName: templateStage.name,
          missedDays,
          safeDelayDays,
        });

        if (!currentStageTracking.notifications_sent) {
          currentStageTracking.notifications_sent = [];
        }
        currentStageTracking.notifications_sent.push({
          type: "warning",
          day: missedDays,
          sent_at: new Date(),
        });

        if (currentStageTracking.status !== "overdue") {
          currentStageTracking.status = "overdue";
        }

        await notebook.save();
        console.log(
          `üìß ƒê√£ g·ª≠i c·∫£nh b√°o l·∫ßn ${missedDays} cho stage ${notebook.current_stage}`
        );
      } else {
        console.log(`‚è≠Ô∏è ƒê√£ g·ª≠i c·∫£nh b√°o cho missedDay ${missedDays}, b·ªè qua`);
      }
    } else {
      if (
        !hasNotificationBeenSent(
          currentStageTracking.notifications_sent,
          "exceeded",
          missedDays
        )
      ) {
        if (autoSkip) {
          currentStageTracking.status = "skipped";
          currentStageTracking.completed_at = new Date();
          currentStageTracking.is_current = false;

          await sendStageSkippedNotification({
            userId: notebook.user_id,
            notebookId: notebook._id,
            notebookName: notebook.notebook_name,
            stageNumber: notebook.current_stage,
            stageName: templateStage.name,
            missedDays,
            safeDelayDays,
          });

          const nextStageNumber = notebook.current_stage + 1;
          if (nextStageNumber <= template.stages.length) {
            const nextStageTracking = notebook.stages_tracking.find(
              (s) => s.stage_number === nextStageNumber
            );
            if (nextStageTracking) {
              nextStageTracking.is_current = true;
              nextStageTracking.started_at = new Date();
              nextStageTracking.status = "active";
            }
            notebook.current_stage = nextStageNumber;

            console.log(
              `‚è≠Ô∏è T·ª± ƒë·ªông skip stage ${templateStage.stage_number}, chuy·ªÉn sang stage ${nextStageNumber}`
            );
          } else {
            console.log(`üèÅ ƒê√£ h·∫øt stage, kh√¥ng th·ªÉ chuy·ªÉn stage ti·∫øp theo`);
          }

          if (!currentStageTracking.notifications_sent) {
            currentStageTracking.notifications_sent = [];
          }
          currentStageTracking.notifications_sent.push({
            type: "exceeded",
            day: missedDays,
            sent_at: new Date(),
          });

          await notebook.save();
        } else {
          currentStageTracking.status = "overdue";

          await sendStageOverdueNotification({
            userId: notebook.user_id,
            notebookId: notebook._id,
            notebookName: notebook.notebook_name,
            stageNumber: notebook.current_stage,
            stageName: templateStage.name,
            missedDays,
            safeDelayDays,
          });

          if (!currentStageTracking.notifications_sent) {
            currentStageTracking.notifications_sent = [];
          }
          currentStageTracking.notifications_sent.push({
            type: "exceeded",
            day: missedDays,
            sent_at: new Date(),
          });

          await notebook.save();
          console.log(
            `üö® Stage ${notebook.current_stage} ƒë√£ qu√° h·∫°n, y√™u c·∫ßu can thi·ªáp th·ªß c√¥ng`
          );
        }
      } else {
        console.log(`‚è≠Ô∏è ƒê√£ x·ª≠ l√Ω exceeded cho missedDay ${missedDays}, b·ªè qua`);
      }
    }
  } catch (error) {
    console.error(`‚ùå L·ªói khi check notebook ${notebook._id}:`, error);
  }
};

/**
 * ƒê√°nh d·∫•u ho√†n th√†nh task trong checklist
 */
const completeChecklistTask = async (notebookId, taskName) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω", 404);
  }

  const task = notebook.daily_checklist.find((t) => t.task_name === taskName);

  if (!task) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác", 404);
  }

  task.is_completed = !task.is_completed;
  task.completed_at = task.is_completed ? new Date() : null;

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (currentStageTracking) {
    if (task.is_completed) {
      const alreadyCompleted = currentStageTracking.completed_tasks?.some(
        (t) => t.task_name === taskName
      );

      if (!alreadyCompleted) {
        if (!currentStageTracking.completed_tasks) {
          currentStageTracking.completed_tasks = [];
        }
        currentStageTracking.completed_tasks.push({
          task_name: taskName,
          completed_at: new Date(),
        });
      }
    } else {
      if (currentStageTracking.completed_tasks) {
        currentStageTracking.completed_tasks =
          currentStageTracking.completed_tasks.filter(
            (t) => t.task_name !== taskName
          );
      }
    }
  }

  if (notebook.template_id && notebook.template_id.stages) {
    await notebook.updateProgress(notebook.template_id.stages);
    console.log(`üìä Progress updated: ${notebook.progress}%`);
    console.log(
      `üìã Completed tasks in current stage: ${
        currentStageTracking?.completed_tasks?.length || 0
      }`
    );
  }

  if (currentStageTracking) {
    const today = new Date().toISOString().split("T")[0];

    console.log(
      `üîç Checking daily_logs for stage ${notebook.current_stage} on ${today}`
    );

    let dailyLog = currentStageTracking.daily_logs?.find(
      (log) => log.date?.toISOString().split("T")[0] === today
    );

    if (!dailyLog) {
      if (!currentStageTracking.daily_logs) {
        currentStageTracking.daily_logs = [];
      }
      dailyLog = {
        date: new Date(),
        daily_progress: 0,
      };
      currentStageTracking.daily_logs.push(dailyLog);
      console.log(`‚ûï Created new daily_log for ${today}`);
    } else {
      console.log(
        `‚úÖ Found existing daily_log for ${today}: ${dailyLog.daily_progress}%`
      );
    }

    const todayTasks = notebook.daily_checklist || [];
    const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
    const totalTodayTasks = todayTasks.length;

    if (totalTodayTasks > 0) {
      dailyLog.daily_progress = Math.round(
        (completedTodayTasks / totalTodayTasks) * 100
      );
      console.log(
        `üìÖ Daily progress for ${today}: ${dailyLog.daily_progress}% (${completedTodayTasks}/${totalTodayTasks})`
      );
    }
  } else {
    console.warn(
      `‚ö†Ô∏è No currentStageTracking found for stage ${notebook.current_stage}`
    );
  }

  if (currentStageTracking && notebook.template_id) {
    const stageCompletion = await notebook.getCurrentStageCompletion();
    console.log(`üéØ Current stage completion: ${stageCompletion}%`);

    if (stageCompletion >= 100 && !currentStageTracking.completed_at) {
      currentStageTracking.completed_at = new Date();
      console.log(`‚úÖ Stage ${notebook.current_stage} marked as COMPLETED`);

      await notebook.updateProgress(notebook.template_id.stages);
      console.log(`üå± Plant progress updated: ${notebook.progress}%`);
    }
  }

  await notebook.save();

  return notebook;
};

/**
 * L·∫•y t·∫•t c·∫£ observations c·ªßa stage hi·ªán t·∫°i
 * CH·ªà tr·∫£ v·ªÅ observations n·∫øu ƒëang ·ªü ng√†y cu·ªëi c·ªßa giai ƒëo·∫°n
 */
const getCurrentStageObservations = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return [];
  }

  const template = notebook.template_id;
  const currentStage = template.stages.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStage) {
    return [];
  }

  // Ki·ªÉm tra xem c√≥ ph·∫£i ng√†y cu·ªëi c·ªßa giai ƒëo·∫°n kh√¥ng
  const currentDay = notebook.current_day || 1;
  const isLastDayOfStage = currentDay === currentStage.day_end;

  // CH·ªà tr·∫£ v·ªÅ observations n·∫øu ƒëang ·ªü ng√†y cu·ªëi
  if (!isLastDayOfStage) {
    return [];
  }

  return currentStage?.observation_required || [];
};

/**
 * C·∫≠p nh·∫≠t observation cho stage hi·ªán t·∫°i
 */
const updateStageObservation = async (notebookId, observationKey, value) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω", 404);
  }

  const stageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!stageTracking) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y stage tracking", 404);
  }

  const existingObs = stageTracking.observations.find(
    (o) => o.key === observationKey
  );

  if (existingObs) {
    existingObs.value = value;
    existingObs.observed_at = new Date();
  } else {
    stageTracking.observations.push({
      key: observationKey,
      value: value,
      observed_at: new Date(),
    });
  }

  await notebook.save();

  // ‚úÖ Ki·ªÉm tra xem t·∫•t c·∫£ observations ƒë√£ ho√†n th√†nh ch∆∞a
  if (notebook.template_id && notebook.template_id.stages) {
    const currentTemplateStage = notebook.template_id.stages.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (currentTemplateStage && currentTemplateStage.observation_required) {
      const requiredObservations = currentTemplateStage.observation_required;
      const completedObservations = stageTracking.observations.filter(
        (obs) => obs.value === true
      );

      console.log(
        `üìä Observations: ${completedObservations.length}/${requiredObservations.length} completed`
      );

      // N·∫øu t·∫•t c·∫£ observations b·∫Øt bu·ªôc ƒë√£ ho√†n th√†nh (value = true)
      if (completedObservations.length >= requiredObservations.length) {
        console.log(
          `‚úÖ All observations completed for stage ${notebook.current_stage}`
        );

        // ƒê√°nh d·∫•u stage hi·ªán t·∫°i ho√†n th√†nh
        stageTracking.completed_at = new Date();
        stageTracking.status = "completed";

        // C·∫≠p nh·∫≠t progress
        await notebook.updateProgress(notebook.template_id.stages);

        // Chuy·ªÉn sang stage ti·∫øp theo n·∫øu c√≥
        const nextStageNumber = notebook.current_stage + 1;
        if (nextStageNumber <= notebook.template_id.stages.length) {
          console.log(`üîÑ Auto-switching to stage ${nextStageNumber}`);

          // T·∫Øt current flag c·ªßa stage hi·ªán t·∫°i
          stageTracking.is_current = false;

          // B·∫≠t current flag cho stage ti·∫øp theo
          const nextStageTracking = notebook.stages_tracking.find(
            (s) => s.stage_number === nextStageNumber
          );

          if (nextStageTracking) {
            nextStageTracking.is_current = true;
            nextStageTracking.started_at = new Date();
            nextStageTracking.status = "active";
          }

          // C·∫≠p nh·∫≠t current_stage
          notebook.current_stage = nextStageNumber;

          // Kh√¥ng t·∫°o checklist ngay, ch·ªâ t·∫°o khi sang ng√†y m·ªõi
          notebook.daily_checklist = [];
          await notebook.save();

          console.log(
            `‚úÖ Stage switched to ${nextStageNumber} successfully (checklist will be generated on next day)`
          );
        } else {
          console.log(`üèÅ All stages completed!`);
          await notebook.save();
        }
      } else {
        await notebook.save();
      }
    } else {
      await notebook.save();
    }
  }

  return notebook;
};

/**
 * T√≠nh stage hi·ªán t·∫°i d·ª±a tr√™n s·ªë ng√†y ƒë√£ tr·ªìng
 */
const calculateCurrentStage = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return null;
  }

  const template = notebook.template_id;
  const daysPlanted = notebook.current_day;

  const stageInfo = template.getStageByDay(daysPlanted);

  if (stageInfo && stageInfo.stage_number !== notebook.current_stage) {
    await updateCurrentStage(notebookId, stageInfo.stage_number);
  }

  return stageInfo;
};

// ==========================================
// CONTROLLER EXPORTS
// ==========================================

// üìò L·∫•y t·∫•t c·∫£ notebook c·ªßa user
export const getAllByUser = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: { $ne: "deleted" },
  })
    .populate("guide_id", "title category difficulty estimatedTime")
    .populate("template_id", "template_name plant_group status stages")
    .sort({ createdAt: -1 });

  return ok(
    res,
    notebooks,
    { count: notebooks.length },
    "Fetched all notebooks successfully"
  );
});

// üìó L·∫•y chi ti·∫øt notebook theo ID
export const getNotebookById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  })
    .populate(
      "guide_id",
      "title category difficulty estimatedTime description steps"
    )
    .populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  // Th√™m stage_completion % v√†o response (now async)
  const notebookData = notebook.toObject();
  notebookData.stage_completion = await notebook.getCurrentStageCompletion();

  return ok(res, notebookData, null, "Fetched notebook detail successfully");
});

// üìù T·∫°o m·ªõi notebook
export const createNotebook = asyncHandler(async (req, res) => {
  const { notebook_name, guide_id, description, cover_image, planted_date } =
    req.body;

  let plant_type = req.body.plant_type;
  let plant_group = null;
  let autoFoundTemplate = null;

  // ‚úÖ FLOW T·ª∞ ƒê·ªòNG: Guide ‚Üí plant_group ‚Üí Template
  if (guide_id) {
    const guide = await Guide.findById(guide_id);
    if (!guide) {
      return res
        .status(404)
        .json({ success: false, message: "Guide not found" });
    }

    // L·∫•y plant_name v√† plant_group t·ª´ Guide
    plant_type = guide.plant_name || guide.title;
    plant_group = guide.plant_group;

    console.log(`üìó Guide found: ${guide.plant_name} ‚Üí Group: ${plant_group}`);

    // T·ª± ƒë·ªông t√¨m template d·ª±a tr√™n plant_group
    if (plant_group && plant_group !== "other") {
      autoFoundTemplate = await PlantTemplate.findOne({
        plant_group: plant_group,
        status: "active",
      }).sort({ usage_count: -1 }); // L·∫•y template ƒë∆∞·ª£c d√πng nhi·ªÅu nh·∫•t

      if (autoFoundTemplate) {
        console.log(
          `‚úÖ Auto-found template: ${autoFoundTemplate.template_name}`
        );
      } else {
        console.log(`‚ö†Ô∏è No active template found for group: ${plant_group}`);
      }
    }
  }

  if (!plant_type) {
    return res.status(400).json({
      success: false,
      message:
        "plant_type is required. Provide either guide_id or plant_type directly.",
    });
  }

  // T·∫°o notebook v·ªõi plant_group
  const newNotebook = await Notebook.create({
    user_id: req.user.id,
    notebook_name,
    guide_id: guide_id || undefined,
    plant_type,
    plant_group: plant_group || "other",
    description,
    cover_image,
    planted_date: planted_date || new Date(),
  });

  // ‚úÖ T·ª∞ ƒê·ªòNG G√ÅN TEMPLATE n·∫øu t√¨m ƒë∆∞·ª£c
  if (autoFoundTemplate) {
    try {
      const notebookWithTemplate = await assignTemplateToNotebook(
        newNotebook._id,
        autoFoundTemplate._id
      );

      console.log(
        `üéâ Template assigned successfully to notebook ${newNotebook._id}`
      );

      return created(
        res,
        notebookWithTemplate,
        `Notebook created with template: ${autoFoundTemplate.template_name}`
      );
    } catch (error) {
      console.error("‚ùå Error assigning template:", error);
      // V·∫´n tr·∫£ v·ªÅ notebook ƒë√£ t·∫°o, ch·ªâ kh√¥ng c√≥ template
      return created(
        res,
        newNotebook,
        "Notebook created but template assignment failed"
      );
    }
  }

  // Kh√¥ng t√¨m ƒë∆∞·ª£c template ‚Üí tr·∫£ v·ªÅ notebook th∆∞·ªùng
  return created(
    res,
    newNotebook,
    "Notebook created successfully (no template found)"
  );
});

// üîÑ C·∫≠p nh·∫≠t notebook
export const updateNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id },
    req.body,
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  return ok(res, notebook, null, "Notebook updated successfully");
});

// üóëÔ∏è X√≥a m·ªÅm notebook (soft delete - ƒë√°nh d·∫•u deleted)
export const deleteNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id },
    { status: "deleted", deletedAt: new Date() },
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  return ok(
    res,
    { id: notebook._id, status: notebook.status },
    null,
    "Notebook deleted successfully"
  );
});

// ‚ôªÔ∏è Kh√¥i ph·ª•c notebook ƒë√£ x√≥a
export const restoreNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id, status: "deleted" },
    { status: "active", $unset: { deletedAt: "" } },
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found or not deleted" });
  }

  return ok(
    res,
    { id: notebook._id, status: notebook.status },
    null,
    "Notebook restored successfully"
  );
});

// üóëÔ∏è L·∫•y danh s√°ch notebook ƒë√£ x√≥a
export const getDeletedNotebooks = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: "deleted",
  })
    .populate("guide_id", "title category")
    .populate("template_id", "template_name plant_group")
    .sort({ deletedAt: -1 });

  return ok(
    res,
    notebooks,
    { count: notebooks.length },
    "Deleted notebooks fetched successfully"
  );
});

// üíÄ X√≥a vƒ©nh vi·ªÖn notebook (hard delete)
export const permanentDeleteNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findOneAndDelete({
    _id: id,
    user_id: req.user.id,
    status: "deleted", // Ch·ªâ cho ph√©p x√≥a vƒ©nh vi·ªÖn notebook ƒë√£ ·ªü tr·∫°ng th√°i deleted
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found or not in deleted status",
    });
  }

  return ok(res, { id: notebook._id }, null, "Notebook permanently deleted");
});

// üîç T√¨m ki·∫øm notebook theo t·ª´ kh√≥a
export const searchNotebooks = asyncHandler(async (req, res) => {
  const { keyword } = req.query;

  if (!keyword) {
    return res
      .status(400)
      .json({ success: false, message: "Keyword is required" });
  }

  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: { $ne: "deleted" },
    $or: [
      { notebook_name: { $regex: keyword, $options: "i" } },
      { plant_type: { $regex: keyword, $options: "i" } },
      { description: { $regex: keyword, $options: "i" } },
    ],
  })
    .populate("guide_id", "title category difficulty")
    .populate("template_id", "template_name plant_group")
    .sort({ createdAt: -1 });

  const meta = { count: notebooks.length, keyword };
  return ok(res, notebooks, meta, "Search results fetched successfully");
});

// üß© L·ªçc notebook theo ti√™u ch√≠
export const filterNotebooks = asyncHandler(async (req, res) => {
  const { plant_type, status, min_progress, max_progress, sort_by, order } =
    req.query;

  const filter = {
    user_id: req.user.id,
    status: { $ne: "deleted" },
  };

  if (plant_type) filter.plant_type = { $regex: plant_type, $options: "i" };
  if (status && ["active", "archived"].includes(status)) filter.status = status;
  if (min_progress !== undefined || max_progress !== undefined) {
    filter.progress = {};
    if (min_progress !== undefined)
      filter.progress.$gte = parseInt(min_progress);
    if (max_progress !== undefined)
      filter.progress.$lte = parseInt(max_progress);
  }

  let sortOption = { createdAt: -1 };
  if (sort_by) {
    const sortOrder = order === "asc" ? 1 : -1;
    switch (sort_by) {
      case "name":
        sortOption = { notebook_name: sortOrder };
        break;
      case "progress":
        sortOption = { progress: sortOrder };
        break;
      case "created":
        sortOption = { createdAt: sortOrder };
        break;
      case "updated":
        sortOption = { updatedAt: sortOrder };
        break;
    }
  }

  const notebooks = await Notebook.find(filter)
    .populate("guide_id", "title category difficulty estimatedTime")
    .populate("template_id", "template_name plant_group status")
    .sort(sortOption);

  const meta = {
    count: notebooks.length,
    filter: {
      plant_type: plant_type || "all",
      status: status || "all except deleted",
      progress_range: { min: min_progress || 0, max: max_progress || 100 },
      sort_by: sort_by || "created",
      order: order || "desc",
    },
  };

  return ok(res, notebooks, meta, "Filtered notebooks fetched successfully");
});

// üñºÔ∏è Th√™m ·∫£nh v√†o notebook
export const addImage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { image_url } = req.body;

  if (!image_url) {
    return res
      .status(400)
      .json({ success: false, message: "image_url is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  notebook.images.push(image_url);
  await notebook.save();

  return ok(
    res,
    { images: notebook.images, total: notebook.images.length },
    null,
    "Image added successfully"
  );
});

// üßπ X√≥a ·∫£nh kh·ªèi notebook
export const removeImage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { image_url } = req.body;

  if (!image_url) {
    return res
      .status(400)
      .json({ success: false, message: "image_url is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  notebook.images = notebook.images.filter((img) => img !== image_url);
  await notebook.save();

  return ok(
    res,
    { images: notebook.images, total: notebook.images.length },
    null,
    "Image removed successfully"
  );
});

// üå± L·∫•y template ph√π h·ª£p cho notebook
export const getNotebookTemplate = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const template = await getTemplateForNotebook(id);

  if (!template) {
    return res
      .status(404)
      .json({ success: false, message: "No suitable template found" });
  }

  return ok(res, template, null, "Template fetched successfully");
});

// üìå G√°n template cho notebook
export const assignTemplate = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { template_id } = req.body;

  if (!template_id) {
    return res
      .status(400)
      .json({ success: false, message: "template_id is required" });
  }

  const notebook = await assignTemplateToNotebook(id, template_id);

  return ok(res, notebook, null, "Template assigned successfully");
});

// üìä L·∫•y timeline c·ªßa notebook
export const getNotebookTimeline = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ID
  if (!id || id === "undefined" || id === "null") {
    return res.status(400).json({
      success: false,
      message: "Invalid notebook ID",
    });
  }

  const notebook = await Notebook.findById(id).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return ok(
      res,
      null,
      { hasTemplate: false },
      "Notebook ch∆∞a c√≥ template. Vui l√≤ng g√°n template ƒë·ªÉ xem timeline."
    );
  }

  const template = notebook.template_id;

  const timeline = notebook.stages_tracking.map((tracking) => {
    const templateStage = template.stages.find(
      (s) => s.stage_number === tracking.stage_number
    );

    return {
      stage_number: tracking.stage_number,
      stage_name: tracking.stage_name,
      started_at: tracking.started_at,
      completed_at: tracking.completed_at,
      is_current: tracking.is_current,
      duration_days: templateStage
        ? templateStage.day_end - templateStage.day_start + 1
        : null,
      start_day: templateStage ? templateStage.day_start : null,
      end_day: templateStage ? templateStage.day_end : null,
      observations: tracking.observations,
    };
  });

  const timelineData = {
    planted_date: notebook.planted_date,
    current_day: notebook.current_day,
    progress: notebook.progress,
    total_days: template.total_days,
    timeline,
  };

  return ok(res, timelineData, null, "Timeline fetched successfully");
});

// ‚úÖ L·∫•y daily checklist
export const getDailyChecklist = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ID
  if (!id || id === "undefined" || id === "null") {
    return res.status(400).json({
      success: false,
      message: "Invalid notebook ID",
    });
  }

  const checklist = await generateDailyChecklist(id);

  // ‚úÖ Return 200 with empty array instead of 404 for better UX
  if (!checklist) {
    return ok(
      res,
      [],
      { hasTemplate: false },
      "Notebook ch∆∞a c√≥ template. Vui l√≤ng g√°n template ƒë·ªÉ t·∫°o checklist."
    );
  }

  return ok(res, checklist, null, "Daily checklist fetched successfully");
});

// ‚úîÔ∏è ƒê√°nh d·∫•u ho√†n th√†nh task
export const completeTask = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { task_name } = req.body;

  if (!task_name) {
    return res
      .status(400)
      .json({ success: false, message: "task_name is required" });
  }

  const notebook = await completeChecklistTask(id, task_name);

  return ok(res, notebook.daily_checklist, null, "Task completed successfully");
});

// üîÑ C·∫≠p nh·∫≠t stage hi·ªán t·∫°i
export const updateStage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { stage_number } = req.body;

  if (!stage_number) {
    return res
      .status(400)
      .json({ success: false, message: "stage_number is required" });
  }

  const notebook = await updateCurrentStage(id, stage_number);

  return ok(res, notebook, null, "Stage updated successfully");
});

// üëÅÔ∏è L·∫•y observations c·ªßa stage hi·ªán t·∫°i
export const getCurrentObservations = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const observations = await getCurrentStageObservations(id);

  return ok(
    res,
    observations,
    null,
    "Current stage observations fetched successfully"
  );
});

// üìù C·∫≠p nh·∫≠t observation
export const updateObservation = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { observation_key, value } = req.body;

  if (!observation_key || value === undefined) {
    return res.status(400).json({
      success: false,
      message: "observation_key and value are required",
    });
  }

  const notebook = await updateStageObservation(id, observation_key, value);

  // Ki·ªÉm tra xem c√≥ chuy·ªÉn stage kh√¥ng
  const currentStage = notebook.stages_tracking.find((s) => s.is_current);
  const previousStageNumber = req.body._previousStage || notebook.current_stage;

  if (currentStage && currentStage.stage_number > previousStageNumber) {
    return ok(
      res,
      notebook,
      {
        auto_transitioned: true,
        new_stage: currentStage.stage_number,
        stage_name: currentStage.stage_name,
      },
      `‚úÖ ƒê√£ ho√†n th√†nh t·∫•t c·∫£ ƒëi·ªÅu ki·ªán quan s√°t! T·ª± ƒë·ªông chuy·ªÉn sang ${currentStage.stage_name}.`
    );
  }

  return ok(res, notebook, null, "Observation updated successfully");
});

// üîç T√≠nh stage hi·ªán t·∫°i d·ª±a tr√™n s·ªë ng√†y
export const calculateStage = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const stageInfo = await calculateCurrentStage(id);

  if (!stageInfo) {
    return res
      .status(404)
      .json({ success: false, message: "Cannot calculate stage" });
  }

  return ok(res, stageInfo, null, "Stage calculated successfully");
});

// üîÑ Recalculate progress (debug endpoint)
export const recalculateProgress = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
  }).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found or no template assigned",
    });
  }

  // Recalculate progress
  await notebook.updateProgress(notebook.template_id.stages);
  await notebook.save();

  const stageCompletion = await notebook.getCurrentStageCompletion();

  return ok(
    res,
    {
      progress: notebook.progress,
      stage_completion: stageCompletion,
      template_stages: notebook.template_id.stages.map((s) => ({
        stage_number: s.stage_number,
        name: s.name,
        weight:
          s.weight || Math.round(100 / notebook.template_id.stages.length),
      })),
      stages_tracking: notebook.stages_tracking.map((s) => ({
        stage_number: s.stage_number,
        stage_name: s.stage_name,
        is_current: s.is_current,
        completed: !!s.completed_at,
      })),
    },
    null,
    "Progress recalculated successfully"
  );
});

// üîß Migrate old notebooks to add completed_tasks field
export const migrateNotebooks = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
  }).populate("template_id");

  let migratedCount = 0;

  for (const notebook of notebooks) {
    let needsSave = false;

    // Check each stage_tracking
    for (const stageTracking of notebook.stages_tracking) {
      // If no completed_tasks, initialize empty array
      if (!stageTracking.completed_tasks) {
        stageTracking.completed_tasks = [];
        needsSave = true;
      }
    }

    if (needsSave) {
      await notebook.save();
      migratedCount++;
      console.log(
        `‚úÖ Migrated notebook: ${notebook.notebook_name} (${notebook._id})`
      );
    }
  }

  return ok(
    res,
    {
      total: notebooks.length,
      migrated: migratedCount,
      already_updated: notebooks.length - migratedCount,
    },
    null,
    `Migration complete! ${migratedCount} notebook(s) updated`
  );
});

// ==========================================
// STAGE MONITORING EXPORTS
// ==========================================

// üîç Ki·ªÉm tra m·ªôt notebook c·ª• th·ªÉ (manual trigger)
export const checkSingleNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findById(id).populate("template_id");

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Kh√¥ng t√¨m th·∫•y notebook",
    });
  }

  await checkNotebookStageStatus(notebook);

  return ok(
    res,
    {
      notebook_id: notebook._id,
      notebook_name: notebook.notebook_name,
      current_stage: notebook.current_stage,
      stages_tracking: notebook.stages_tracking.map((s) => ({
        stage_number: s.stage_number,
        stage_name: s.stage_name,
        status: s.status,
        missed_days: s.missed_days,
        is_current: s.is_current,
      })),
    },
    null,
    "Notebook stage status checked successfully"
  );
});

// üîÑ Monitor t·∫•t c·∫£ notebooks (admin/cron endpoint)
export const monitorAllNotebooks = asyncHandler(async (req, res) => {
  console.log("üîç B·∫Øt ƒë·∫ßu monitor t·∫•t c·∫£ notebooks...");

  try {
    const notebooks = await Notebook.find({
      status: "active",
      template_id: { $exists: true, $ne: null },
    }).populate("template_id");

    console.log(`üìä T√¨m th·∫•y ${notebooks.length} notebooks c·∫ßn ki·ªÉm tra`);

    for (const notebook of notebooks) {
      await checkNotebookStageStatus(notebook);
    }

    console.log("‚úÖ Ho√†n th√†nh monitor t·∫•t c·∫£ notebooks");

    return ok(
      res,
      {
        total_checked: notebooks.length,
        timestamp: new Date(),
      },
      null,
      "All notebooks monitored successfully"
    );
  } catch (error) {
    console.error("‚ùå L·ªói khi monitor notebooks:", error);
    return res.status(500).json({
      success: false,
      message: "Error monitoring notebooks",
      error: error.message,
    });
  }
});
